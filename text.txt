import StealthPlugin from 'puppeteer-extra-plugin-stealth'

import { escapers } from '@telegraf/entity'
import { bot } from '../bot'
import vanilla from 'puppeteer'
import { addExtra } from 'puppeteer-extra'
import { Cluster } from 'puppeteer-cluster'

const exactPath = {
	linux: '/usr/bin/google-chrome',
	win32: 'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
} as const

const browserInstance = async () => {

	const puppeteer = addExtra(vanilla)

	puppeteer.use(StealthPlugin())

	const cluster = await Cluster.launch({
		concurrency: Cluster.CONCURRENCY_PAGE,
		puppeteer: puppeteer,
		maxConcurrency: 2,
		puppeteerOptions: {
			headless: 'new',
			args: [
				'--no-sandbox',
				'--disable-setuid-sandbox',
				'--disable-cache',
				'--ignore-certificate-errors',
				'--ignore-certificate-errors-spki-list',
				'--ignore-ssl-errors',
				'--disable-dev-shm-usage',
				'--disable-accelerated-2d-canvas',
				'--disable-gpu',
				'--disable-notifications',
				'--disable-extensions',
				'--mute-audio'
			],
			ignoreDefaultArgs: ['--disable-extensions'],

			userDataDir: './datafile',
			executablePath: exactPath[process.platform as keyof typeof exactPath]
		}
	});

	return cluster
}

class GPT {

	async init() {

		const browser = await browserInstance()

		browser.task(async ({ page, data }) => {

			page.setRequestInterception(true)

			page.on('request', (request) => {
				if (request.resourceType() === 'image') {
					request.abort()
				} else if (request.resourceType() === 'font') {
					request.abort()
				} else if (request.resourceType() === 'cspviolationreport') {
					request.abort()
				} else if (request.resourceType() === 'stylesheet') {
					request.abort()
				} else {
					request.continue()
				}
			})

			await page.goto(
				data.url,
				{
					waitUntil: 'domcontentloaded'
				}
			)

			const input = await page.waitForSelector(
				'#prompt-textarea'
			)

			if (!input) {
				throw new Error('Input not found')
			}

			await input.click({ count: 1, delay: 100 })

			await page.type(
				'#prompt-textarea',
				`Sou ${data.name}, ${data.message}`,
				{
					delay: 2
				}
			)

			const send = await page.$(
				'[data-testid="send-button"]'
			)

			if (!send) {
				throw new Error('Send button not found')
			}

			await send.click({ count: 1, delay: 100 })

			await page.waitForSelector('.markdown')

			await page.waitForTimeout(10000)

			const output = await page.evaluate(() => {

				const output = Array.from(document.querySelectorAll('.markdown p:not([style])'));

				const messages: string[] = []

				for (const message of output) {
					const text = message.textContent;
					if (!text) continue
					messages.push(text)
				}

				let message: string = ''
				for (const msg of messages) {
					message += `${msg}\n`
				}

				const code = Array.from(document.querySelectorAll('.markdown code:not([style])'));

				let codeMessage: string | null = null
				let linguagem: string | null = null
				for (const co of code) {
					const c = co.textContent;
					if (!c) continue
					if (linguagem === null) linguagem = co.classList[co.classList.length - 1].split('-')[1]
					codeMessage = c.replace(/[-*_()[\]~`>#+=|{}.!]/g, '\\$&').replaceAll(/"/g, "\\\"").replaceAll('!', '\\!')

				}

				return {
					text: message,
					code: codeMessage,
					linguagem: linguagem
				}
			})

			console.log(output)

			try {

				let template = ''

				template += `${escapers.MarkdownV2(output.text)}\n\n`

				if (output.code !== null) {
					let code = output.code as string
					template += "```" + output.linguagem + '\n' + code + "```"
				}


				await bot.telegram.sendMessage(
					data.chat_id,
					template,
					{
						parse_mode: 'MarkdownV2',
						reply_to_message_id: data.message_id
					}
				)
			} catch (error) {
				console.log(error)
			}


		});

		return browser
	}

}

export { browserInstance, GPT as default }
